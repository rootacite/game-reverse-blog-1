# 逆向工程实践记录： {游戏资源文件结构分析 （一）}

- [逆向工程实践记录： {游戏资源文件结构分析 （一）}](#逆向工程实践记录-游戏资源文件结构分析-一)
  - [0x00 最终目的概述](#0x00-最终目的概述)
  - [0x01 目标对象](#0x01-目标对象)
  - [0x02 前期准备](#0x02-前期准备)
    - [初步观察与假设](#初步观察与假设)
    - [思路整理](#思路整理)
  - [0x03 分析步骤详解](#0x03-分析步骤详解)
    - [熵分析](#熵分析)
    - [导入表反向追踪](#导入表反向追踪)
    - [DrawStringAt() 反向回溯](#drawstringat-反向回溯)
    - [动态调试问题解决](#动态调试问题解决)
    - [附：一个差点被错过的隐藏花活](#附一个差点被错过的隐藏花活)
  - [0x04 总结(AI帮我写的)](#0x04-总结ai帮我写的)

> 日期：2025-08-03  
> 作者：ShiYuan Li  
> 分析平台：Voidraw OS v1.1 (Based on Ubuntu)  
> 运行平台：Windows 11 Pro (虚拟机 VMware Workstation)  
> 工具链：IDA Pro 9.1、x64dbg  
> 难度：7.8/10.0 （AI评的分）

---

## 0x00 最终目的概述

- 分析目标程序的文字资源文件 “.WAR”的结构
- 修改程序最终文字显示结果
- 编写简单的打包/解包程序
- 挑战：禁用反反调试插件，靠自己去解决问题

## 0x01 目标对象

> 概述：目标对象为一个单机文字RPG游戏程序。

- 架构：x86 （32位）
- 加壳：高度疑似VMP加密，或其他定制壳，多种混淆手段

原文件以文本形式加密附于项目中，本文仅描述思路，不直接提供程序文件(**AES256-ECB、{key: SHA-256-YJYBigSB}**)。

## 0x02 前期准备

### 初步观察与假设

> 游戏启动后，从同一目录下的“.WAR”文件中读取游戏资源，可能包括音乐、美术资源、文字资源、演出逻辑等。 

> 如[图1](#p00)所示，根据导入表分析，该程序依赖于gdi32.dll，但未见DirectX或OpenGL相关依赖，故而推测该程序依赖GDI接口进行绘图。

<a name="p00"></a>
![图1 导入表](./pics/00.png)

### 思路整理

从本次逆向分析的目的出发，结合初步的假设（程序使用GDI绘图），不难思考出两条可行的基本路径。

1. 从文字显示逻辑处反向回溯，追踪用于显示的字符串，最终找到生成解码后文字的逻辑，由其分析出资源文件结构。
2. 从文件操作系统调用开始，追踪文件句柄，找到读取文件的逻辑，观察程序如何处理从文件中读取到的数据。
   
此次逆向分析目标的运行平台为Windows，接口为GDI，故而用于文字显示的系统接口主要包括**GetGlyphOutline**、**TextOut**，这两个函数是此次逆向分析的重要锚点。此外，Windows平台中的文件操作API包括**CreateFile**、**ReadFile**、**WriteFile**。

## 0x03 分析步骤详解

### 熵分析

对资源文件进行熵分析可以判断资源文件是否被加密或压缩，虽然这不能直接判断文件结构，但可以对后续的分析提供一定的思路。 

Linux下，常用ent工具进行熵分析，其可以用下面的指令安装。

```sh
sudo apt install ent
```

普通文本文件的熵值通常在4-5之间，如果熵值接近8（>7），则说明文件很有可能被加密或压缩。

<a name="p01"></a>
![图2 熵分析](pics/01.png)

根据[图2](#p01)中的测试结果，资源文件的熵值都非常接近8,故而推测他们是被压缩或加密的。

### 导入表反向追踪

在IDA Pro中打开目标程序后，在Imports中找到函数**GetGlyphOutlineA**，对其进行交叉引用搜索。

![图3 交叉引用1](pics/02.png)

从图中的结果可知，主要有两个函数引用了**GetGlyphOutlineA**，它们的起始地址分别是**4389C0H**和**438C50H**。

这两个函数的签名如下：

```C
int __cdecl sub_438C50(int, BOOL hdc, int x, int y, ULONG_PTR lpString, int c);
int __cdecl sub_4389C0(int, SYSTEMTIME lpgm, UINT_PTR uChar);
```

根据交叉引用图分析判断，**sub_4389C0**仅被**sub_438C50**显式调用，而**sub_438C50**同时调用了**TextOutA**和**GetGlyphOutlineA**，并且是**GetGlyphOutlineA**的唯一调用源。

并且**sub_438C50**的函数签名中包含一个字符串指针参数、一个绘图句柄以及疑似坐标的两个整数，这是非常值得注意的一个点。

| **sub_4389C0** | **sub_438C50** |
|-----|-----|
| ![p03a](pics/03A.png) | ![p03b](pics/03B.png) |

> 由此推测，**sub_438C50**函数的功能为在指定位置绘制字符串，将其重命名为 **“DrawStringAt()”**。

### DrawStringAt() 反向回溯

![图4 交叉引用2](pics/04.png)

根据交叉引用图分析，DrawStringAt的唯一调用者为**sub_439940**，签名如下：

```C
void __cdecl sub_439940(int c, HDC hdc, int);
```

如下图所示，对**sub_439940**进行反汇编分析发现，在这个函数的末尾，一个短时的**Sleep**会被无条件执行：

![图5 Code0](pics/05.png)

这一点很值得注意，因为此类操作的意义通常是临时交出CPU控制权，避免长时间占死某个CPU核心。那么这说明**sub_439940**具有什么特征呢？首先，它没有等待IO操作，事件，信号或者Windows Message一类的东西，因为这类等待并不是锁死在CPU上忙等待的，而是通过OS调度来实现，其次，**这个函数很可能需要被高频循环调用**，进一步说，它可能就是在某个线程中被死循环调用的，所以才需要在一次调用结束后用**Sleep**交出CPU控制权。

再进一步分析，什么样的功能需求会产生这样的设计？有很多，但是在这里可以根据经验猜两个可能性比较高的。

1. 这个函数是整个图形应用的消息循环处理器
2. 这个函数是游戏引擎的Tick事件处理器

而在这两个猜测中，我比较偏向于猜想(1)，因为这个函数特别大并且逻辑复杂，当然也不能排除这是因为编译器把很多子例程内联了进去，这些问题还要进一步研究。

那么来验证一下上面进行的诸多猜想。一个简单的方法是用动态调试器，打上一个日志断点，观察函数的调用来源。

### 动态调试问题解决

在动态调试过程中遇到了一些小问题，目标程序如果独立运行就没有问题，但如果用调试器附加就会闪退。其实很多原因都能引起这个问题，有的简单有的复杂。但如果想找到问题的根源，通常第一步就是**仔细观察这个程序到底是以什么形式退出的**，是Crash还是Terminate、或者说它自己选择退出。

首先，在EntryPoint和WinMain上打断点，然后一路Continue，程序再次出现闪退问题后查看Log。

![图6 动态调试Log1](pics/06.png)

从这个Log中能获取到很多信息：

1. EntryPoint和WinMain函数确实被执行。
2. 并没有发生明显的Crash，程序很有可能是自己退出的。

在上面这两个信息的驱动下，其实就可以直接去研究WinMain函数本身了。因为start引用WinMain，既然程序是自己退出的，十有八九就是WinMain自己返回了。果不其然，往下拉一拉就能发现作者耍的”小聪明“。

![图7 反调试1](pics/07.png)

那对付这种程度的反调试，直接把对应的分支指令Patch掉就好了。

![图8 反调试solve1](pics/08.png)

但是随后出现了另一个问题，就是程序报”Initialization failed“，独立运行程序时同样没有这个问题。我的第一反应是，由于我Patch掉了反调试的分支跳转指令，所以导致一些关键的初始化步骤被跳过，然而目前没有证据或迹象驱动这个方向的分析。

那么目前就有两种猜测：

1. 这个作者在某个子过程中又加了一次反调试，没有被我Patch掉，但检测到就说是初始化失败。
2. 确实是一些目前位置的调试器相关的原因，引起了初始化失败。

但无论如何，罪魁祸首多半就是**sub_408BB0**返回了错误的结果，对其进一步分析可以发现，**sub_408BB0**申请了一块可执行的内存，并将起始地址传入了子过程**415720H**。  


进入415720H处的子过程后，首先扑面而来的就是毫不掩饰的干扰反汇编的花指令。

![图10 反调试solve3](pics/10.png)

从指令字节中可以很明显看到，程序在进行了一系列无实际意义的操作后，用cmp指令确保ZF标志为1，然后用je指令跳转到0x415736。如果从头顺序解释的话，这个地址应该是两条指令的中间，很显然这个地方才是真正的指令边界，我们直接编辑内存，把前面的无意义操作替换为nop。

| **清除花指令过程** | **清除后的代码** |
|-----|-----|
| ![p11a](pics/11A.png) | ![p11b](pics/11B.png) |

重新分析二进制代码，可以发现**415720H**处的子过程引用了之前申请的可执行内存，以及另一块静态数据。

其实到了这一步，局面已经比较清晰了，那就是这个程序极其有可能使用了类似于VMP的加密壳保护自己的一些逻辑。为了进一步验证这一猜测，我们等**40A320H**处的解密释放程序执行完成后，跟进到esi指向的地址。

![图12 VMP](pics/12.png)

**对味了！对味了！**

那么在这种情况下，继续和这一坨东西硬碰硬，去尝试拆分逻辑、Dump，性价比就非常低。不妨釜底抽薪，让这段严防死守的代码所依赖的调试器检测接口不再可靠。恰巧，x64debug里面就提供了这样的一个方便的指令：

> dbh hide

这条指令可以让反调试依赖的常规接口，比如PEB+BeingDebugged、IsDebuggerPresent失效，从而绕过。

但是这一次，如果你认为问题到这就解决了，那就会感受到软件作者从2014年给你送过来的“恶意”。

![图13 史](pics/13.png)

像上面这种手段，我的评价是伤害一般，含史量较高。非常明显，这就是有意的在代码中触发异常，给你的调试器喂史。

可能你会想，“这怎么还伤害一般呢？这哪有伤害啊？我把这一句代码Patch掉不就行了“，但是这就错了。因为作者会把一部分代码逻辑放到SEH里面，如果你把这个引发异常的空指针解引用Patch掉，那后面的代码就会直接罢工。

所以在这种情况下，效率最高的一种方案就是让调试器不要去管这个异常，同时也不要去干扰SEH。

**但是，但是又来了**，如果你感觉到这里就结束了，那作者又对你微微一笑 :)。为什么呢？因为他在SEH里面又塞了一个调试器检测：

![图13 史2](pics/14.png)

这个逻辑还是很”简练“的，某个子过程中调用了一个我现在没兴趣去研究做了什么的函数，然后根据函数的返回值去迭代，迭代过几轮之后，如果满足某个条件，就让这个SEH过程返回0，否则返回1。

那很显然，这个程序的行为就是故意去解引用一个空指针，然后在SEH里面检测调试器。如果检测到就把异常传递到OS层面，否则就继续执行。

那么这一次，作者又用了什么手段呢？只能再继续跟进去看看了。

顺带一提，这种情况下，你想直接在IDA里画交叉引用图一般是没戏的，因为作者在搞这种操作的时候不会把一个静态的地址放在那里直接call，就像下面这样：

![图14 史3](pics/15.png)

我们只能用动态调试去跟踪到这个位置，观察实际的call地址后再到IDA中分析：

| **跟踪动态调用** | **函数入口点** |
|-----|-----|
| ![p11a](pics/16A.png) | ![p11b](pics/16B.png) |

到这一步之后，就可以再次回到IDA中，用交叉引用图去揪出捣鬼的家伙了。

![图15 史4](pics/17.png)

上面这张交叉引用图乍一看，最显眼的就是这个**UnhandledExceptionFilter**，这个函数通常是当一个异常没有被任何捕获机制成功处理时，由OS自动调用的，用户代码主动去call是一个反常现象。

作者这样操作的意图其实也不难猜，其中一种动机是他用**SetUnhandledExceptionFilter**设置了一个顶层的处理过程，然后在那个过程中又塞了一个调试器检测，但是在这个程序中，**SetUnhandledExceptionFilter**从来没有被调用过，并且跟踪**UnhandledExceptionFilter**的后续流程可以发现，EIP马上转到了kernelbase.dll的上下文中，这是Windows默认的顶层异常处理函数所在的区域，所以这个猜测可以被否定了。

另一种动机就需要一些反调试经验，或者对Windows底层原理有比较细节的了解才能想到了，我们不妨来看一看MSDN的官方文档（url：https://learn.microsoft.com/en-us/windows/win32/api/errhandlingapi/nf-errhandlingapi-unhandledexceptionfilter）：

![图16 msdn1](pics/18.png)

你看这上面说，**UnhandledExceptionFilter**在什么情况下会返回0啊？ **“The process is being debugged, so the exception should be passed (as second chance) to the application's debugger.”**——被调试的时候。

根据MSDN的说法，**UnhandledExceptionFilter**在没有调试器附加时会返回1，那我们能不能直接把这个call指令Patch成 **“mov eax, 1”** 呢？

> 看似合理，实则不行。

因为UnhandledExceptionFilter返回1的情况是操作系统直接弹出一个报错框，然后把这个进程终止掉。程序作者肯定不会让调试器检测系统在程序正常运行时把他搞崩溃，没错吧？所以他会用**SetErrorMode**来将这个进程的错误处理模式设置成**SEM_NOGPFAULTERRORBOX**，在这种情况下，UnhandledExceptionFilter的返回值是 **-1(EXCEPTION_CONTINUE_EXECUTION)**，而不是**1(EXCEPTION_EXECUTE_HANDLER)**。

并且，**UnhandledExceptionFilter**的内部逻辑会让SEH记录的断点信息改变，所以这里最合适的做法是Hook一个Nt函数**NtQueryInformationProcess**，让这个函数的输出信息不包括调试器信息。

到这里为止，作者就没再搞什么花活了。程序顺利在调试器下运行。

### 附：一个差点被错过的隐藏花活

这里的内容是我后添的，因为实在太有意思了。在上面的过程中，我直接用**Hook NtQueryInformationProcess**的方法绕过了利用**UnhandledExceptionFilter**的反调试逻辑。但其实这个地方我欠思考了，直接选择了一个比较偷懒的通解法。那么现在我们来探讨一下：

> 直接把那句主动调用的**UnhandledExceptionFilter**Patch成**mov eax, -1**，到底行不行？

Windows中，SEH链实际指向的函数，其原型并不是我们在C语言中定义的那样，后者是：

```C
LONG __stdcall ExceptionHandler(
    struct _EXCEPTION_POINTERS* ExceptionInfo
);
```

而SEH(fs:[n])实际指向的函数原型是下面这样的：

```C
EXCEPTION_DISPOSITION __cdecl _except_handler3(
    struct _EXCEPTION_RECORD *ExceptionRecord,
    void * EstablisherFrame,
    struct _CONTEXT *ContextRecord,
    void * DispatcherContext
);
```

其中第三个参数保存了异常发生点的上下文信息，并且如果这个函数返回了0的话，Windows就不会继续在SEH链上遍历下一个Handler，而是根据**ContextRecord**中存储的上下文信息，调用**NtContinue**让发生异常的线程回到发生异常的指令继续执行。

**(画重点：发生异常的指令不会被跳过，而是会被重新执行)**

拥有这些前置知识之后，我们就可以回到作者故意引发异常的那一条指令处。

| **引发异常的指令** | **SEH Handler** |
|-----|-----|
| ![p11a](pics/19A.png) | ![p11b](pics/19B.png) |

即将执行那条引发异常的指令时，我们记下寄存器的值。随后在SEH函数的入口点 **(可以通过fs:[0]找到)** 打上断点，让代码继续执行进入SEH（如上左图所示）。

EIP指向SEH的第一条指令时，我们可以根据 **_except_handler3**的原型定义和调用约定(cdcel反向压栈)在内存中找到**ContextRecord**结构体。

> esp指向返回地址  
> esp+04H指向第一个参数  
> esp+08H指向第二个参数  
> esp+0CH指向第三个参数(ContextRecord)  

在内存视图中，可以观察到从**19F5A4H+B0H**开始的三个**uint32**值分别为：**000000H**、**19FD10H**和**409E89H**,根据 **_CONTEXT**结构体的定义，可以判断这三个值分别是**eax**、**ebp**、**eip**。

然后，我们让注意力回到引发异常的指令前，这里有一个十分重要的 **“伏笔”**：

![图17 msdn1](pics/20.png)

注意红框里面的指令(这里是用AT&T语法写的)：

```asm
lea ($409E8B), %edx
push $64
push %edx
```

你可能会觉得： **“这有什么好看的？这看起来就是往堆栈上存了两个数啊？就是两个局部变量吧？”**。  
但如果再仔细想想，你会发现两个问题。

第一个问题就只是有点可疑，那就是堆栈里面保存的数值恰好是异常指令的下一条指令地址，并且这个数不是通过读eip存进去的，而是一个常量地址引用。

而第二个问题，一般你很难发现，但只要你发现了绝对吓你一跳——**这个函数的堆栈是不平衡的**，不信你可以数一数。如果那条指令不引发异常，这个函数正常向下走，那这个程序就绝对会崩溃。因为执行到ret的时候esp不指向返回地址。

分析到这个地方，我卖个关子。读者可以先自己思考一下为什么这个明显会崩溃的函数可以正常运行。

然后，就像前面说的那样，我们把那条主动调用**UnhandledExceptionFilter**的指令Patch成**mov eax, -1**，再让程序运行到SEB Handler的末尾：

| **Patch代码** | **执行到SEH Handler末尾** |
|-----|-----|
| ![p21a](pics/21A.png) | ![p21b](pics/21B.png) |

通过寄存器和内存试图，我们能获取到几个信息。

1. 首先eax为0，这说明系统不会搜索下一个SEH项，而是会直接按照CONTEXT结构中存储的上下文恢复。
2. CONTEXT中保存的上下文信息没被动过，这意味着出错的指令会以同样的上下文，再执行一次。

<span style="font-size: 24px; font-weight: bold; ">那不就是会再出错一次吗？？？</span>

完全正确！事实也是这样。如果像上面那样直接Patch，程序就会进入出错->SEH->再出错->再SEH...的死循环。

接下来再来看一看，在程序正常运行的情况下，执行**UnhandledExceptionFilter**后会发生什么：

![图22](pics/22.png)

如上图所示，除了返回-1外，**CONTEXT**结构体保存的eip被修改为了**7676D720H**，这个地址在Windows WOW64中指向的是Sleep函数，这意味着SEH函数执行完成后，eip会被恢复到Sleep函数的地址。

注意，**这不是call**，而是eip直接被设置为Sleep函数的地址。正常来讲，因为返回地址没有被推进堆栈中，Sleep函数执行完成后eip会直接“跑飞”，无法到达一个有意义的指令地址。但事实是，它能正常运行。

> 回忆一下，前面是不是也有一件不太正常的事？程序在前面是不是往堆栈里面多推了两个DWORD？

如果这个时候，你能恍然大悟，直呼精彩，那你就已经Get到逆向分析的爽点了！这就是软件作者与逆向者的脑力博弈，兜兜转转，实际上就是在解一道引人入胜的谜题。

而如果读者还没有明白，我就解释一下。

当eip被恢复到Sleep的时候，esp也会被恢复到发生异常时的esp，而那个时候，堆栈最顶部的两个数值一个是异常指令的下一条，一个是立即数64。这两个数刚好作为了Sleep函数的参数和返回地址，同时也让程序跳过了引发异常的指令，执行它的下一条指令。

<span style="font-size: 18px; font-weight: bold; ">作者在两个地方制造了两个会让堆栈失衡的设计，但两处合在一块堆栈就会回归平衡。而且，一般只有程序没有被调试的时候，两个异常点才会同时起作用，你单独Patch任何一个程序都无法运行！</span>

艺术！

## 0x04 总结(AI帮我写的)

本次逆向工程实践主要围绕目标程序的资源文件结构分析和反调试机制展开，取得了以下成果：

1. **资源文件初步分析**  
   - 通过熵分析确认`.WAR`资源文件被加密/压缩（熵值≈8）
   - 为后续解包/打包工具开发奠定基础

2. **显示逻辑逆向**  
   - 定位关键函数`DrawStringAt()`及其调用链
   - 明确程序基于GDI接口的文字绘制流程

3. **反调试机制破解**  
   - 绕过`UnhandledExceptionFilter`调试检测
   - 破解堆栈平衡"花活"（双异常点协同设计）
   - 动态+静态分析结合突破VMP壳保护逻辑

4. **工具链验证**  
   - Voidraw OS + Win11虚拟机环境适配
   - IDA Pro与x64dbg协同调试方案优化

5. **待续......**